#+title: M1 Writeup
#+author: 


#+startup: showeverything

#+latex_header: \usepackage{amsmath,amssymb,fullpage,dsfont,setspace}
#+latex_header: \newcommand{\bs}{\boldsymbol}
#+latex_header: \newcommand{\attn}[1]{\textbf{***{#1}***}}
#+latex_header: \newcommand{\src}{\attn{source}}
#+latex_header: \setlength{\parskip}{\baselineskip}
#+latex_header: \newcommand{\logit}{\text{logit}}

#+latex_header: \setstretch{1.5}

* Checklist							   :noexport:
** Notation
   - [ ] Locations
     - [ ] Coordinates
     - [ ] Covariates
     - [ ] Neighbors
   - [ ] Dynamics model
     - [ ] Gravity model
** Spread dynamics models
   - [ ] $1 - \Pi_{i}[ 1 - P_{i,j}]$
   - [ ] Gravity model
   - [ ] Gravity model with time infected
   - [ ] Range model
   - [ ] Cave model
   - [ ] Setting generative model parameters
** Structure generation
   - [X] Covariates
   - [ ] Network distance
   - [-] Structures
     - [X] Alley
     - [ ] Bowtie
     - [ ] Grid
     - [X] Random
     - [ ] Ring
     - [ ] Scalefree
** Simulation details
   - [ ] Start settings
   - [ ] Significant points
     - [ ] Model estimation
     - [ ] Strategy estimation
   - [ ] Number of time points
   - [ ] Objective function
   - [ ] Optimization online tuning
   - [ ] Model estimation
** Priority scores
   - [ ] Form of the scores
   - [ ] Selection process
   - [ ] Features
** M1 Optimization
   - [ ] Runners
   - [ ] SGD
** Competing policies
   - [ ] Proximal
   - [ ] Myopic
     
     
   # begin document
   
* Notation
  
  Each location $i \in \mathcal{L}$ lies in a $R^2$ at coordinate pair
  $C_i$.  The matrix $\Omega$ is a binary matrix indicating adjacent
  locations.  For any two locations $i$ and $j$, $\Omega_{i,j} = 1$ if
  location $j$ is adjacent to location $i$.  We define the network such
  that locations are adjacenty to themselves, $\Omega_{i,i} = 1$ for all
  $i$.  All networks defined will be undirected thus $\Omega_{i,j} =
  \Omega_{j,i}$ for all $i,j$.  The adjacency matrix is the defining
  component of the network.  For some of the networks, the adjacency
  matrix can be defined without knowing the coordinate pairs, but for
  other networks the coordinate pairs are required to generate the
  adjacency matrix.  Regardless of the network, we outline every step to
  generate the network in its entirety.

  Defining distance between to locations in a network, for most of the
  following structures, is the geodesic distance where each edge has
  length $1$ regardless of the coordinate values.  For the ring and
  starred alley, we make some modifications to the edge lengths before
  calculating the geodesic distance.  These details are covered in the
  respective sections.
  
  When defining networks, some additonal notation may be added to keep
  the process clear and concise.
  
  To model the spread of the disease, we assume that once a location
  becomes infected, it remains infected thereafter.  The infection
  status for location $i$ at time $t$ is $X_{i,t} = 1$ if infected and
  $X_{i,t} = 0$ otherwise.  Thus $X_{i,t} \ge X_{i,t'}$ for all $t > t'$.
  
  Let the subscript operator $[\cdot]$ denote the usual order
  statistics; let $\lfloor \cdot \rfloor$ denote the floor operator; let
  $\lceil \cdot \rceil$ denote the ceiling operator.
  
  
* System dynamics model
  
** Gravity model
   
   To model the evolution of the disease, we model the probability that
   an infected location $i$ infects an uninfected location $j$ at time
   point $t$.  We denote this probability as $p_{i,j,t}$.  If we assume
   independence across events $i$ infecting $j$ and $i'$ infecting $j$,
   the probability of $j$ becoming infected at time $t$ is
   #+BEGIN_LaTeX
     \begin{equation*}
     P(X_{j,t} = 1 | X_{\cdot,t-1}) = X_{j,t-1} \bigvee \left[1 - \prod_{i:
     X_{i,t-1} = 1} ( 1 - p_{i,j,t} ) \right].
     \end{equation*}
   #+END_LaTeX
   
   To define $p_{i,j,t}$ we use a form of the gravity model.
   #+BEGIN_LaTeX
     \begin{equation*}
     \logit \; p_{i,j,t} = \beta_0 + \beta_1 U_j 
     - \alpha \frac{d_{i,j}}{(c_ic_j)^\nu} - \eta g_j(\tau_{i,t})
     - \rho A_{j,t-1} - \gamma A_{i,t-1}
     \end{equation*}
   #+END_LaTeX
   where $\tau_{i,t} = \sum_{t' = 0}^t X_{i,t'}$ is the number of time
   points $i$ has been infected.  We compare different forms of
   $g_j(\cdot)$ discussed later.  The name of the model comes from
   $d_{i,j}/(c_i,c_j)^\nu$ which is known as the gravity term.  The
   effect of distance between two locations is diminished if the number
   of caves in the two locations is large.  We assume as the number of
   caves increases, so does the number of bats effectively decreasing the
   effect of distance.  The vector $U_j$ is a vector of covariates as
   part of the state information.  These covariates include the number of
   caves, average winter length, area, species richness, and number of
   hibernating bat species.
   
   For model estimation, we use a Bayesian framework.  The priors on the
   parameters are as follows $\beta_0 \sim N(0,100)$, $\beta_1 \sim
   N(0,10)$, $\log(\alpha) \sim N(0,1)$, $\log(\nu) \sim N(0,1)$.  The
   priors for $\rho$ and $\gamma$ will be specified later.  For WNS, the
   observed data does not include information about treatments.  This
   requires an ad-hoc selection of the true treatment effects.  The prior
   distributions during the simulations for these parameters will over
   estimate the true effect.
   
** Model fit diagnostics
   
   When estimating the posterior distributions, we compared multiple
   forms for $g(\cdot)$.
   #+BEGIN_LaTeX
     \begin{itemize}
     \item ``zero'': $g_j(x) = 0$
     \item ``linear'': $g_j(x) = x - 1$
     \item ``exp'': $g_j(x) = exp(x - 1) - 1$
     \item ``exp\_caves'': $g_j(x) = exp(\frac{\max_k c_k+1}{c_j + 1}(x - 1)) - 1$
     \end{itemize}
   #+END_LaTeX
   
   
   #+BEGIN_SRC R :session :exports none
     rm(list=ls(all=TRUE))


     library(ggplot2)
     library(reshape2)
     library(grid)
     library(gridExtra)
     library(xtable)
     library(RColorBrewer)

     datDir = paste("/home/nick/research/spatialDecisionMaking",
         "data/wns/2015-03-08-14-51-11",sep="/")

     obsStats = read.table(paste(datDir,"obsStats_.txt",sep="/"),header=TRUE)

     file_gravity = paste(datDir,"sampStats_gravity_.txt",sep="/")
     file_timeInf = paste(datDir,"sampStats_timeInf_.txt",sep="/")
     file_timeInfExp = paste(datDir,"sampStats_timeInfExp_.txt",sep="/")
     file_timeInfExpCaves = paste(datDir,"sampStats_timeInfExpCaves_.txt",sep="/")

     sampStats_gravity = read.table(file_gravity,header=TRUE)
     sampStats_timeInf = read.table(file_timeInf,header=TRUE)
     sampStats_timeInfExp = read.table(file_timeInfExp,header=TRUE)
     sampStats_timeInfExpCaves = read.table(file_timeInfExpCaves,header=TRUE)

     sampStats_gravity = cbind(sampStats_gravity,"zero")
     sampStats_timeInf = cbind(sampStats_timeInf,"linear")
     sampStats_timeInfExp = cbind(sampStats_timeInfExp,"exp")
     sampStats_timeInfExpCaves = cbind(sampStats_timeInfExpCaves,"exp_caves")

     names(sampStats_gravity)[ncol(sampStats_gravity)] = "timeInf"
     names(sampStats_timeInf)[ncol(sampStats_timeInf)] = "timeInf"
     names(sampStats_timeInfExp)[ncol(sampStats_timeInfExp)] = "timeInf"
     names(sampStats_timeInfExpCaves)[ncol(sampStats_timeInfExpCaves)] = "timeInf"

     getBayesP <- function(dat,obs,nm){
         res = unlist(sapply(1:ncol(obsStats),function(i){
             mean(obs[1,i] < dat[,i])}))
         res = data.frame(res=res)
         names(res) = nm
         row.names(res) = names(obs)
         return(res)
     }

     bayesP = data.frame(
         getBayesP(sampStats_gravity,obsStats,"zero"),
         getBayesP(sampStats_timeInf,obsStats,"linear"),
         getBayesP(sampStats_timeInfExp,obsStats,"exp"),
         getBayesP(sampStats_timeInfExpCaves,
                   obsStats,"exp_caves")
         )

     msrVars = names(sampStats_gravity)[-ncol(sampStats_gravity)]

     sampStats_all = rbind(sampStats_gravity,
         sampStats_timeInf,
         sampStats_timeInfExp,
         sampStats_timeInfExpCaves)

     sampStats_all = melt(sampStats_all,measure.vars=msrVars)

     sampStats_all$timeInf = factor(sampStats_all$timeInf)

     th = theme(
         title = element_text(size=20),
         text = element_text(size=18),
         axis.ticks.x = element_blank(),
         axis.text.x = element_blank(),
         legend.key.size = unit(".5","in")
         )



     p = list()
     for(i in levels(sampStats_all$variable)){
         s = sampStats_all[sampStats_all$variable == i,]
         pI = ggplot()
         pI = pI + geom_boxplot(data=s,
             aes(x = variable, y = value, fill = timeInf))
         pI = pI + geom_hline(yintercept = obsStats[,i],
             color="firebrick",size=2,linetype="dashed")
         pI = pI + scale_fill_manual(name = "Time Infected",
             values = brewer.pal(6,"Set3"))
         pI = pI + xlab(gsub("_"," ",i))
         pI = pI + th
         p = c(p,list(pI))
     }
   #+END_SRC
   
   
   The table below shows the Bayesian P-value for each of the four
   transformations above.  Using an exponential transformation greatly
   improves the estimated p-values.  Going forward, we choose the
   ``exp\(\_\)caves'' transformation as providing the best fit.
   #+BEGIN_SRC R :session :exports results :results output latex
     bayesP = rbind(bayesP,colMeans(bayesP))
     row.names(bayesP)[nrow(bayesP)] = "Column Mean"
     bayesP = rbind(bayesP,t(apply(bayesP,2,median)))
     row.names(bayesP)[nrow(bayesP)] = "Column Median"
     bayesP = rbind(bayesP,t(apply(bayesP,2,sd)))
     row.names(bayesP)[nrow(bayesP)] = "Column SD"
     print(xtable(bayesP,digits=4,caption="Bayesian p-values for postulated models."),
           hline.after=c(0,ncol(obsStats),nrow(bayesP)),label="tab:bayesP")
   #+END_SRC
   
   
* Structure generation
  
** Structures
   
*** Random Network
    
    For each location $i=1,\ldots,L$, $C_i \sim \lbrace U(0,1)\rbrace^2$.
    To determine which locations are connected, we must first define some
    notation.  Let $E_{i,j} = \|C_{i} - C_{j}\|_2$.  The set of $k$ nearby
    locations to location $i$ is $N^{(k)}_i = \lbrace j : E_{i,j} \le
    E_{i,[k+1]} \rbrace$.  Note the detail $[k+1]$ which is a consequence
    of $E_{i,i} = 0$.  The adjacency matrix is defined as $\Omega_{i,j} =
    1$ if $i \in N_{j}^{(k)}$ or $j \in N_{i}^{(k)}$.

    
    #+caption: A random network with 50 locations
    #+name: fig:rand50
    #+attr_latex: :width 0.5\textwidth
    [[./data/toy/randSample.pdf]]
    
    
    
*** Starred Alley
    
    For a starred alley of size $L$, define
    #+BEGIN_LaTeX
      \begin{equation*}
      m_L= \underset{m > 0}{\arg\max} \; f(m) \mathds{1}_{\lbrace f(m) \le L
      \rbrace }
      \end{equation*}
    #+END_LaTeX
    where
    #+BEGIN_LaTeX
      \begin{equation*}
      f(m) = m + \left\lceil \frac{m}{2}
      \right\rceil 
      \left(\left\lceil \frac{m}{2} \right\rceil
      - (m \text{ mod } 2) + 1 \right).
      \end{equation*}
    #+END_LaTeX
    
    Let locations $1,\ldots,m_L$ index the locations on the main
    horizontal line.  Next define disjoint sets of locations
    $N_i$ for $i = 1,\ldots,m_L.  The cardinality for
    $N_i$ is defined as
    #+BEGIN_LaTeX
      \begin{equation*}
      | N_i | = \left\lfloor \frac{i}{2} \right\rfloor +
      \mathds{1}_{\lbrace(m_L - i) < (L - f(m_L))\rbrace}.
      \end{equation*}
    #+END_LaTeX
    For each location $j \in N_i$ set $\Omega_{i,j} = \Omega_{j,i} = 1$.
    For the first $m_L$ locations, $\Omega_{i,i+1} = \Omega_{i+1,1} = 1$ for
    $i = 1,\ldots,m_L$.
    
    To define the coordinates for each location, first set $C_{i} =
    \lbrace i,0 \rbrace$ for $i = 1,\ldots,m_L$.  Then for each $i$,
    we set the coordinates for all nodes in $N_i$ according to
    #+BEGIN_LaTeX
      \begin{equation*}
        C_{j_{N_i}} = 
        \begin{cases}
          rot(j\pi/(\lceil |N_i|/2 \rceil + 1)) (-1,0) + C_i & j = 1,\ldots,
          \lceil |N_i|/2 \rceil\\
          rot(j\pi/(\lfloor |N_i|/2 \rfloor + 1)) (0,1) + C_i & j = \lceil
          |N_i|/2 \rceil + 1,\ldots,|N_i|
        \end{cases}  
      \end{equation*}
    #+END_LaTeX
    where
    #+BEGIN_LaTeX
      \begin{equation*}
      rot(\theta) = \left[
      \begin{matrix}
      \cos(\theta) & -\sin(\theta)\\
      \sin(\theta) & \cos(\theta)
      \end{matrix}
      \right].
      \end{equation*}
    #+END_LaTeX
    
    Distances between locations is defined as geodesic distance, but
    the edges do not all have length $1$.  Distance between location
    $i$ and $j$ is
    #+BEGIN_LaTeX
      \begin{equation*}
        d_{i,j} = 
        \begin{cases}
          | i - j | & i,j \in \lbrace 1,\ldots,m_L \rbrace\\
          | i - k | + .9 & j \in N_k \text{ and } i \in \lbrace 1,\ldots,m_L
          \rbrace\\
          | k - j | + .9 & i \in N_k \text{ and } j \in \lbrace 1,\ldots,m_L
          \rbrace\\
          | k - \ell| + 1.8 & i \in N_k \text{ and } j \in N_\ell \text{ and
            } k,\ell \in \lbrace 1,\ldots,m_L
        \end{cases}
      \end{equation*}
    #+END_LaTeX
    
    
    #+caption: The starred alleyway network with 50 locations
    #+name: fig:alley50
    #+attr_latex: :width 0.5\textwidth
    [[./data/toy/alleySample.pdf]]
    
    
    
*** Ring
    
    Divide the number of locations $L$ into two groups.  Define $L_1 =
    L - L_2$ where $L_2 = \lceil L*0.05 \rceil$.  Let $\theta =
    2\pi/(L_1+1)$ and $r = 1/(2\sin(\theta/2))$.  Place location $1$
    at $C_1 = \lbrace 0,r \rbrace$.  Given location $i-1$ at
    $C_{i-1}$, place location $i$ at $C_i = rot(\theta) C_{i-1}$ for
    $i = 2,\ldots,L_1$.  Note that $C_{1} \cdot C_{L_1} = \|C_{1}\|
    \|C_{L_1}\| \cos(2\theta)$.
    
    With the first $L_1$ locations defined, we need to define the last
    $L_2$ locations.  Place location $L_1 + i$ at $C_{L_1 + i} =
    rot(\theta/L_2)C_{L_1 + i - 1}$ for $i = 1,\ldots,L_2$.  Note that
    $C_{L} \cdot C_{L_1} = \|C_{L}\| \|C_{L_1}\| \cos(\theta)$ and $C_{1}
    \cdot C_{L} = \|C_{1}\| \|C_{L}\| \cos(\theta)$.
    
    To define the adjacency matrix, $A_{i,i+1} = A_{i+1,i} = 1$ for $i =
    1,\ldots,L-1$ and $A_{1,L} = A_{L,1} = 1$.
    
    
    
    #+caption: The ring network with 50 locations
    #+name: fig:ring50
    #+attr_latex: :width 0.5\textwidth
    [[./data/toy/ringSample.pdf]]
    
    
    
    
*** Grid
    
    First define $L_1$ to be the number of columns and $L_2$ to be the
    number of rows.  These values are defined by
    #+BEGIN_LaTeX
      \begin{equation*}
      \lbrace L_1, L_2 \rbrace = \underset{
      \begin{subarray}{c}
      \ell_1,\ell_2 > 0\\
      \ell_1\ell_2 = L\\
      \ell_1 \le \ell_2
      \end{subarray}
      }{\arg\min} \quad |\ell_1 - \ell_2|
      \end{equation*}
    #+END_LaTeX
    
    Location $i$ is positioned at $C_i = \lbrace (i \text{ mod } L_2), \lfloor
    i/L_2 \rfloor \rbrace$.  The adjacency matrix is defined as $\Omega_{i,j} =
    1$ if $\|C_i - C_j\| = 1$.
    
    #+caption: The grid network with 50 locations
    #+name: fig:grid50
    #+attr_latex: :width 0.5\textwidth
    [[./data/toy/gridSample.pdf]]
    
    
    
*** Bowtie
    
    The bowtie combines two grid networks with a random network in
    between.  Spread of the disease begins in one grid and travels through
    the random network and into the other grid.
    
    For a bowtie network of size $L$, create one random network of size
    $L_R = \lceil 0.1 L \rceil + ((L - \lceil 0.1 L \rceil) \text{ mod }
    2)$ and two grid networks of size $L_G = (L - L_R)/2$.  Let $i_{R}$ be
    the $i^{th}$ location in the random network and $i_{G_j}$ be the
    $i^{th}$ location in the $j^{th}$ grid.
    
    To connect the three networks, we need to first identify which nodes
    in each network will connect to one of the other two networks.  We
    will begin with the first grid.  First, define $L_1$ and $L_2$ to be
    defined in the same way as in the grid description.  Let $M_{G} =
    \lceil L_2/3 \rceil$ be the number of points to connect from the grid
    networks and $M_{R} = \lceil L_R/5 \rceil$.  Define the following four
    sets of locations
    #+BEGIN_LaTeX
      \begin{equation*}
      \begin{array}{rcl}
      \Lambda_{G_1} & = & \lbrace L_G -
      2L_1M_G + kL_1 : k = 1,\ldots,M_G\rbrace\\
      \Lambda_{G_2} & = & \lbrace L_G -
      2L_1M_G + 1 + (k-1)L_1 : k =
      1,\ldots,M_G\rbrace\\
      \Lambda_{R_1} & = & \lbrace i : C_{i_R,1} \le C_{[M_R]_{R},1} \rbrace\\
      \Lambda_{R_2} & = & \lbrace i : C_{i_R,1} \ge C_{[L_R - M_R + 1]_{R},1} \rbrace.
      \end{array}
      \end{equation*}
    #+END_LaTeX
    
    To define the adjacency matrix, combine the adjacency matrices from
    the three separate networks as a block diagonal matrix.  To define the
    additional edges, set $\Omega_{i_{G_1},j_R} = \Omega_{j_R,i_{G_1}} =
    1$ for all $i \in \Lambda_{G_1}$ and $j \in \Lambda_{R_1}$ to connect
    the first grid to the random network.  Then set $\Omega_{i_{G_2},j_R}
    = A_{j_R,i_{G_2}} = 1$ for all $i \in \Lambda_{G_2}$ and $j \in
    \Lambda_{R_2}$ to connect the second grid to the random network.
    
    Now that the adjacency marix is defined, we need to finish the
    network.  The last step is scaling and adjusting the coordinates from
    the three networks.  We define this as an ordered list of operations.
    #+BEGIN_LaTeX
      \begin{enumerate}
      \item For $i=1,\ldots,L_R$: $C_{i_{R}} = C_{i_{R}}/2$.
      \item Define $K = (\max_i C_{i_{R},1} - \min_i C_{i_{R},1})/2$.
      \item For $i=1,\ldots,L_R$: $C_{i_{R},1} = C_{i_{R},1} -
      \min_j C_{j_{R},1} + \max_j C_{j_{G_1},1} + K$
      \item For $i=1,\ldots,L_G$:
      $C_{i_{G_2},1} = C_{i_{G_2},1} - \min_j C_{j_{G_2},1} + \max_j
      C_{j_{R},1} + K$.
      \end{enumerate}
    #+END_LaTeX
    
    
    #+caption: The bowtie network with 50 locations
    #+name: fig:bowtie50
    #+attr_latex: :width 0.5\textwidth
    [[./data/toy/bowtieSample.pdf]]
    
    
*** Scalefree
    
    The scalefree network is designed so that some locations are highly
    connected while others are only connected by a couple edges.  This
    type of network was originally desigined to mimic the network of
    webpages.  The internet houses many websites that are highly connected
    (e.g. Google, Yahoo, etc.) while the majority are not.
    
    To generate the network of size $L$, we will define the process via
    induction.  Define $\Omega^{(i)}$ to be the adjacency network on
    iteration $i = 1,\ldots,L$.  A network of size $1$ is the trivial
    network.  Given a network of size $N-1$, place the additonal $N^{th}$
    location adjacent to an existing location $i \in \lbrace
    1,\ldots,N-1\rbrace$ with probability
    #+BEGIN_LaTeX
      \begin{equation*}
      P(\Omega^{(N)}_{N,i} = 1 | \Omega^{(N-1)}) = 
      \frac{\sum_{j!=i} \Omega^{(N-1)}_{j,i}}{\sum_{j,k \;:\; j > k} \Omega^{(N-1)}_{j,k}}.
      \end{equation*}
    #+END_LaTeX
    
    Generating a scale-free network in this fashion results in a
    Barabasi-Network.  The defining feature of a scale-free network is the
    proportion of nodes with $k$ edges is proportional to $k^{-\gamma}$
    for some $\gamma$.  In a Barabasi-Network $\gamma = 3$.
    
    Given the adjacency matrix, we use the Fruchterman-Reingold algorithm
    to position the nodes in a two dimensional plane.
    
    
    #+caption: The scalefree network with 50 locations
    #+name: fig:scalefree50
    #+attr_latex: :width 0.5\textwidth
    [[./data/toy/scalefreeSample.pdf]]
    
    
    
    
** Covariates
   
   Define $X$ to be a $n \times p$ centered and scaled covariate matrix.
   The covariates are multivariate normal $MVN_p(\mu,\Sigma)$ where
   $\mu_i = 2\widetilde{C}_{i,1}^2 + 1\widetilde{C}_{i,2}$ and
   $\widetilde{C}$ are the centered and scaled coordinates.  The
   covariance matrix has the structure $\Sigma_{ip + s, jp + t} =
   \rho e^{(-\tau  E_{i,j} - \eta |s-t|)}$.  Thus, the variance of the
   individual covariates are $1$ and the correlation decays as $E_{i,j}$
   increases and as $|s-t|$ increases.
   
   We need the mass of each individual node to compute the gravity term
   in the gravity model.  In the case of White-Nose Syndrome, the mass is
   the number of caves.  Arbitrarily set the first covariate to be the
   mass of the node.  Define $M_i = \lfloor X_{i,1} - X_{[1],1} \rfloor +
   1$ to be the mass of location $i$.
   
   
** Network distance
   
   In order for the structure of the network to have a strong impact on
   the disease spread, we define distance as the geodesic distance raised
   to a power.  The distance between adjacent nodes ($i$ and $j$ such
   that $A_{i,j} = 1$) is defined to be $1$.  For non-adjacent nodes, the
   distance is the number of edges along the shortest path raised to a
   power.  To determine the appropriate power, let $p^{(1)}_{i,j}$ be the
   hypothetical probability node $i$ infects node $j$ where $i$ and $j$
   have geodesic distance $1$.  Let $p^{(2)}_{i,j}$ be the hypothetical
   probability if infection if $i$ and $j$ have geodesic distance $2$.
   For their mass, use the mean mass of the network.  The log odds-ratio
   is equal to
   #+begin_latex
     \begin{equation*}
     - \frac{\alpha}{m^\rho} + \frac{\alpha2^z}{m^\rho}.
     \end{equation*}
   #+end_latex
   Set this equation equal to $\log(0.5)$ and solve for $z$.
   
   
* Simulations
  
  The simulations begin at time point $0$ and end at $T=15$.  Observed
  data from WNS has data from $8$ years.  When simulating the spread
  of the disease under intervention, treatments are not given until
  time point $8$ to mimic the observed data.

  At time point $8$, we estimate the posterior distributions of the
  indexing parameters in the system dynamics model.  Note that there
  are no treatments yet in the data, so the posterior for the
  treatment effects are simply the prior.  Using the estimated
  posterior distributions, the simultaneous perturbation algorithm is
  run to maximize the posterior mean reward at time $T$.  The reward
  funtion at time $t$ is the current proportion of locations infected,
  $Y^t(\pi) \triangleq \frac{1}{L}\sum_i X_{i,t}$.

  At $t = 9$, the process is the same with one addition.  Since the
  data now include a year of treatments, we run the tuning algorithm
  for simultaneous perturbation to adaptively improve the performance.
  Time points $t=10,\ldots,T$ are the same as $8$.

  The prior for the treatment effects are set to be optimistic.  They
  are normal with mean $4$ times as large as the true effect and
  variance $1$.
  
  
* Results
  
** Simultaneous perturbation experiment
   
   To calibrate the simultaneous perturbation algorithm, we ran a full
   factorial experiment over the following levels.
   #+BEGIN_LaTeX
     \begin{itemize}
       \item $A \in \lbrace 30, 50 \rbrace $
       \item $B \in \lbrace 1, 10 \rbrace $
       \item $C \in \lbrace 2, 5 \rbrace $
       \item $L \in \lbrace 1, 1.25 \rbrace $
       \item $T \in \lbrace 1, 2 \rbrace $
     \end{itemize}
   #+END_LaTeX
   
   #+BEGIN_SRC R :session :exports none
     rm(list=ls(all=TRUE))

     library(xtable)

     datDir = paste("/home/nick/research/spatialDecisionMaking",
         "data/toy/grid100/2015-03-03-18-51-38/results",sep="/")
     res = read.table(paste(datDir,"results_.txt",sep="/"),header=TRUE)

     pm = c("+","-")

     res$Afac = pm[as.numeric(factor(res$A))]
     res$Bfac = pm[as.numeric(factor(res$B))]
     res$Cfac = pm[as.numeric(factor(res$C))]
     res$Tfac = pm[as.numeric(factor(res$T))]
     res$Lfac = pm[as.numeric(factor(res$L))]


     resAll = res[,c("value","time","Afac","Bfac","Cfac","Tfac","Lfac","combo")]

     mnAgg = aggregate(res$value,by=list(res$combo),FUN=mean)
     sdAgg = aggregate(res$value,by=list(res$combo),FUN=sd)
     tmAgg = aggregate(res$time,by=list(res$combo),FUN=mean)

     names(mnAgg) = c("combo","valueMean")
     names(sdAgg) = c("combo","valueSd")
     names(tmAgg) = c("combo","timeMean")

     resAgg = res[1:32,]
     resAgg = merge(resAgg,mnAgg,by="combo")
     resAgg = merge(resAgg,sdAgg,by="combo")
     resAgg = merge(resAgg,tmAgg,by="combo")

     resAgg = resAgg[,c("valueMean","valueSd","timeMean","Afac","Bfac","Cfac","Tfac","Lfac","combo")]
   #+END_SRC
   
   
   For each of the $32$ combinations, the table below shows the mean and
   standard deviation of the value across all replications of that factor
   combination.  The results are sorted by the mean value.

   #+BEGIN_SRC R :session :exports results :results output latex
     print(xtable(resAgg[order(resAgg$valueMean,decreasing=FALSE),],
                  digits=c(0,3,3,3,0,0,0,0,0,0),align="rrrrcccccr",
                  caption="Results from the simultaneous perturbation experiment."),
           include.rownames=FALSE,label="tab:simPertExp")
   #+END_SRC
   


** Agent jitter and num chunks experiment
   
** Toy Structures
   
** WNS
